\documentclass[../report.tex]{subfiles}
\begin{document}
\graphicspath{{img/}{../img/}}

\section{Overview}
This chapter will describe important implementation details of Ocon. The system is realized by three main components. A central, a widget and a client. In addition a communication library have been created to facilitate distributed communication between the three components.


\section{Encapsulation of Context}

Entities are generalized by the interface IEntity, specifying general information for all entities. AbstractEntity extends on IEntity and overrides ToString() with a meaningful implementation. Both are public and it is up the an implementer which to extend.

On figure \ref{fig:PersonImplementation} is extended a Person with property present motivated by the need for this context information.


\begin{figure}[H]
\includegraphics[width=\linewidth]{customEntityClass.png}
\caption{Person as a custom IEntity implementation}
\label{fig:PersonImplementation}
\end{figure}



\section{Situation predicate evaluation}
%\todo{Short on how we evaluate predicates} %

Situations are evaluated on their predicate property. When we say predicate we are talking about the .NET implementation, which is a delegate\footnote{http://msdn.microsoft.com/en-us/library/900fyy8e.aspx} returning a boolean value. The signature for our predicate is as below. This means that a method taking an ICollection of IEntity and returning a boolean can be assigned to the predicate property.

\begin{center}
\texttt{Predicate<ICollection <IEntity> >}
\end{center}


This way it is totally up to an implementor to design the code that evaluates whether a predicate is true or false.

\section{Communication}

To support the design decision that the communication part should be injectable the communication have been interfaced in IOconCom.

Ocon contains a default communication implementation build using the TCP/IP layer. For serialization we have chosen to use JSON. These decisions have been made so that developers are not bound to the .NET platform and can make clients and widgets in other languages like Java, or C directly on a micro controllers like Arduino.

For peer discovery we have chosen to use IP multicast. The central broadcasts itself for peers to discover. The peer, clients and widgets, is listening on the multicast endpoint and will invoke an event when a central is discovered.

To facilitate discovery OconTcpCom implements two methods: Broadcasting and DiscoveryService. Both methods are running on threads. This is done so that that peers are not blocked when broadcasting or discovering. When a peer is discovered an DiscoveryService event will be fired to notify subscribers.

To listen and send for sending Entites, situation updates and situation subscription following methods have been implemented: Listen, SendEntity, SendSituationState, and SubscribeSituaion. When listen is called a new thread is started and whenever a message is received either IncommingSituationSubscribtionEvent, IncommingEntityEvent, or IncommingSituationChangedEvent is fired to notify subscribers. Then different send methods are also executed on a thread. This have been done to avoid blocking and to get faster execution time as multiple messages can be sent at the same time.

The send methods take a peer. The peer is a helper class. Just like entities, peers are assigned a GUID. The GUID is a unique identifier for the peer and the communication class stores the IPEndPoints associated with the GUIDs. When a message from a peer is received or discovered the IpEndPoint is saved in a HashSet. By doing this messages can be sent only by using the peer and not the IPEndPoint which adds an abstraction layer to the module. 

\section{Widget}
\label{sec:OconWidget}

The widget's purpose is to track entities and keep them updated in the central. The widget developer should translate sensor input to entities and then the Ocon widget will facilitate tracking the entity and sending it to the central. (See figure \ref{fig:widgetComHelper})

\begin{figure}
\hspace{-70px}
\includegraphics[width=500px]{comHelperSequence-widget.png}
\caption{Widget to Central sequence diagram}
\label{fig:widgetComHelper}
\end{figure}

The OconWidget is very light. When constructed the widget will listen for OconCentrals by starting discovery and subscribing to DiscoveryServiceEvents in the communication module. When a central is found an event will be fired and the central will be added as subscriber. OconWidget has only one methods. Notify(IEntity entity). When Notify is called from the sensor a check weather or not the entity is already tracked is performed. If not tracked it will be allocated a new GUID before it is sent to the central through the communication module. The GUID is a unique ID used for distributed systems and allows Ocon to distinguish between adding the entity as a new entity or updating an entity already know to the framework. The usage of the widget is very easy for application developers as they only have to use one method when sending new entities to the central.

\section{OconClient}
The OconClient's purpose is to sent predicates to the central for tracking. When a situation update is send from the central the client must be able to notify the parent application about the situation update. (See figure \ref{fig:clientComHelper})

\begin{figure}
\hspace{-70px}
\includegraphics[width=500px]{comHelperSequence-client.png}
\caption{Client to Central sequence diagram}
\label{fig:clientComHelper}
\end{figure}

The OconClient is, as the OconWidget, very light. It contains only a constructor and a SituationStateChanged Event. The constructor takes a list of predicate identifiers as parameter, subscribes to DiscoveryServiceEvents, and starts the discovery service. When a DiscoveryServiceEvent is invoked the OconClient send its predicate identifiers to the OconCentral.

Per design the client was suppose to send a predicate and not a predicate identifier. To support clients being able to send predicates to the central, predicates must be serialized, but this is unfortunately not supported in .NET. Frameworks for handling the serialization have been researched, but none of the investigated frameworks were able serialize the predicates in Ocon as custom types are used. Therefore serializing predicates was forced out of scope. Instead of sending the predicates, they are hard coded in the central. The OconClient can then subscribe them by sending a predicate identifier. 

\todo{Move to reflection (The text is out commented)}
%This limits the usage of Ocon, but it was not possible to include this feature in this project. A framework for serializing the predicates as expression trees should be doable, but that project is left for a later iteration of Ocon. 

The OconCentral will upon receiving the predicate identifiers send back the state of the subscribed predicates. When OconClient was constructed it also subscribed IncommingSituationChanged event in the communication module. When such an event is fired OconClient will fire its SituationStateChanged event notifying subscribing applications of the predicate change.


\section{Central}
OconCentral is the core component of the framework. Utilization simply means instantiation and afterwards registration of situations.

The OconCentral implementation is a simple binding from the ContextCentral to the ICommunication implementation, making it possible for a developer to use the OconContextFilter in isolation. The OconContextFilter handles all tracking of entities, situations and checking of predicates. Entities are stored in a HashSet<> with a custom EqualityCompare implementation so that the Guid acts as unique identifier. This is necessary for updating informations on entities, but a consequence is that a widget implementation needs to track it's entities as well, to be able to update them with the filter. Evaluation of situation predicates happens whenever an entity is requested tracked.
\end{document}