\documentclass[]{report}


\usepackage[autostyle]{csquotes} 
\usepackage{parskip}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage{wrapfig}
\usepackage{epigraph}
\usepackage[T1]{fontenc}
\usepackage{titlesec, blindtext, color}
\definecolor{gray75}{gray}{0.75}
\newcommand{\hsp}{\hspace{20pt}}
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}
\makeatletter
\newif\if@right
\def\shadequote{\@righttrue\shadequote@i}
\def\shadequote@i{\begin{snugshade}\begin{quote}\openquote}
\def\endshadequote{%
  \if@right\hfill\fi\closequote\end{quote}\end{snugshade}}
\@namedef{shadequote*}{\@rightfalse\shadequote@i}
\@namedef{endshadequote*}{\endshadequote}
\makeatother









\begin{document}

\graphicspath{{img/}{../img/}}
\input{./title.tex}

\begin{abstract}
\end{abstract}


\chapter{Project description}
A Context-aware system is able to adapt its behavior to the surroundings it is in. In order to act upon its environment, the system will need sensor-input. Various sources of input can be used to determine the actions of the system.\\

In this project we want to mainly focus on implementing a context-awareness framework, making it easy for systems to actuate on sensor events. As a proof of concept we will explore replacing the physical SCRUM board, which is often a whiteboard and post-its, with an IT-solution which is not confined to a personal computer, but has the same presence. The digital SCRUM board will be context-aware to the extent that it can recognize different SCRUM activities, like sprint meeting or one-on-one, and automatically change its graphical interface.


\chapter{Scope of this project}

As per our Project description there are two artifacts to be made; The context awareness framework and a proof of concept implementation in form of a Context-aware Scrum board.

\paragraph{The Framework.} 
Our project description dictates that the main piece of work will be our framework, and so implementation of this framework will have the broadest scope.\\

\begin{itemize}
\item[\textbf{Goal 1 }] \textit{Our aim is to implement a framework that is adaptable and easy to use.}
\end{itemize}


\paragraph{The Scrum board.} 
For us to prove usability of the framework developed we will implement it for a context-aware Scrum board. The function of this artifact is solely to test the usefulness of the context-awareness framework.\\

\begin{itemize}
\item[\textbf{Goal 2 }] \textit{In trying to prove Goal 1, implement a stub Scrum board utilizing the framework}
\end{itemize}

It is not in our scope to implement a functional or useful Scrum board.











  

\chapter{Design Choices}

This chapter describes the different design choices we have though about in developing the framework.

To establish a vocabulary:
	Situation - A physical situation eg. A person sitting down
	
	Context - Context is knowing the situation and being able to react and be accordingly
	
	Context information - Every information that aggregates a context
	

\section{Background Research}
To be able to make a context-aware framework, we first had to investigate what context and context-awareness is in a computer science perspective.


When being face-to-face with a person people can interpret the situation and that is a very important factor in effective communication. 

When communication with computers they can not understand and interpret the situation and that leads to inefficient human-machine interaction. Context-aware computing can apply situation information to machines.

Context-awareness is a term associated with Ubiquitous computing also known as Pervasive computing.

Ubiquitous computing, ubicomp, was coined in the early nineties by Mark Weiser whose vision was to make technology that could seamlessly assist in everyday tasks. Weisers research-unit at Xerox PARC developed some of the first mobile devices, and the development of ubi computing clearly reflects in todays technology boom of smart phones and tablets.

Many of the publications on the subject describes it different, but the one description fitting best our understanding was coined by Dey and Abowd whom described context as:


\blockquote{
	\textit{Any information that can be used to characterize the situation of an entity. An entity is a person, place or object that is considered relevant to the interaction between a user and an application, including the user and application themselves.} \cite{Dey and Abowd (2000)} 
}

We will in this project be focused on how we can effectively model situation in computer software.


\section{Grand Architecture}
The theory available to us mainly describes two main approaches for building a context-aware framework: Blackboard and Widget.


The blackboard approach is a centralized solution. Sensors and clients are connected to the blackboard and when ever a new sensor state is available a postit, an entry to the database, is put on the blackboard. The client can at will look through the blackboard and search for context it might find relevant.

The widget approach is an object-oriented distributed solution. Sensors encapsulated by widgets are available for client subscription. The solution is event based and clients are notified whenever a change to the sensor is occurring. This solution is object-oriented as the context is modeled with objects sent from sensor to client. This time and spare coupled solution stands in contrast to the blackboard approach which is a database and is therefore time- and spare uncoupled.

The solution differs a lot in the way the model context, but the main differers is in the way of delivering context from sensor to client.

As mentioned the solutions stands in great contrast when looking at space and time coupling. To briefly describe the theory, space coupling is weather or not the sender knows who the receiver of a message is. Time coupling is if the given message is only available in real-time. 

Where the blackboard at any time offers clients to go though it's context database, it does not offer notifying the client, as the blackboard is space uncoupled, and does not know about the client.

The widget solution offers live updated only when they happens and only to the clients subscribing for the update.

Both solutions are very useful in different applications.

For example a hospital system where you want to use the context framework to track patients, the blackboard solution seams to meet requirements best as you can, when needed, look up a patients whereabout in the hospital.

For a home automation system using sensors, sensor input is only interesting the moment it happens, and only to actuator whom it concern. When a person enters the room the light should go on instantly, only in the room where the person entered and only at the given time.


\section{Central}

When looking at the blackboard and widget based methods, we have decided that we want to include a little of both.

We want to do a centralized system where clients can register a predicate. A predicate could be that the client would like to be notified whenever the situation is that a person is sitting down.

The framework should be event-based so when ever the state of a clients predicate changes, an event will be fired to notify the client.  

This combines the blackboards centralization with the widgets time and space coupling making it transparent for the developer which sensor is actually given the input, but also having the space and time coupling from the widget based method.

With this our framework will be an If-this-then-that solution where the client can use sensor input for control without the  client developers having to put much though into using and managing sensors   


\section{Encapsulation of Context-information}
Object-oriented encapsulation of context can be done in a variety of ways.

We have been looking at two different methods. Using a composite pattern and modeling with properties.

Using a composite pattern enforced relations between entities, entities being locations, persons, things or other real world objects.

Lets say we want to model a location with some rooms with some persons with different items or actions. Using the composite modeling we can have a location object containing room objects containing person objects containing item objects. We'll then have a relationship between the objects compositing the context being that a group of students is in room 3A04 at ITU all having phones in their pockets and all sitting down. This is a fairly complex, but a very extensible and flexible way to model situation (See fig \ref{fig:composite}). The downside to this method is that you can easily have an overflow of entities, and that it can be very complex and computation heavy to check against a  predicate.

\begin{figure}[H]
\centering
\includegraphics[width=200px]{composite.png}
\caption{Diagram illustrating composite modeling}
\label{fig:composite}
\end{figure}


The other method we are considering is more simple. Having a set of entities that we wish to track, eg persons. All context information relating to a person will be properties to the object. So to use the previous example, a person entity would then have a location property, being ITU room 3A04, a phone property begin true and a sitting property being true. This model is more easy to make, but it limits the developer to know very precisely what information is needed and should be tracked. The previous model had the advantage of being very flexible allowing more complex relations and situations. 

Both methods have pros and cons being how dynamic they are, how easily they can be implemented, and what performance they will have and that will be the parameters we'll look at when implementing the framework 

\FloatBarrier

\section{Widget}

\section{Client}


\section{Dynamic Entity types}


\section{Communication}

Initially we decided that making the framework distributed would be out scoped, but as the project progressed it was decided to bring it into scope.

The reason for doing so is that our vision of having a centralized system distributing situation from sensors to clients is not very useful if not distributed.

For the framework two different communication protocols need to be implemented.

\begin{itemize}
	\item A protocol for establishing link between peers
	\item A protocol for send text/json messages for updates and notifications
\end{itemize}

We do not wish to bind our users to any concrete communication protocols. Therefore an the communication will be interfaces so a concrete implementation can be dependency inject it into the framework.

The framework will contain a default implementation build using the TCP/IP layer. For serialization we have chosen to use json. These decisions have been made so that developers are not bound to the .NET platform and can make clients and widgets in other languages like Java, or C directly on a micro controllers like Arduino.

For peer discovery we have chosen to use IP multicast. The central will broadcast itself for peers to discover. When a peer is discovered a connection can be established by a TCP/IP handshake. If the developer does not want to use the discovery it can be disabled and a connection can be established solely by a handshake.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth]{comHelperSequence.png}
\caption{Communication Helper sequence diagram}
\label{fig:comHelperSequence}
\end{figure}

\chapter{Design}

\FloatBarrier

\section{Overview}

\begin{center}
\includegraphics[scale=0.2]{ComponentDiagram.png}
\end{center}


\paragraph{The Client} is an observer interested in sensor data. It subscribes to a situation on the ContextCentral.

\paragraph{The Widget} wraps a sensor and translates the raw data to entities which are sent to the ContextCentral.

\paragraph{The ContextCentral} is the central for entity information and situations. When an entity is received from a widget, all stored situations are checked and subscribers notified accordingly.



\section{Encapsulation of Context}
Design choices in encapsulating context

Entities are generalized by the type IEntity, specifying general information for all entities.


\begin{center}
\includegraphics[scale=0.15]{ContextClassDiagram.png}
\end{center}


\section{Widget}

\section{Central}

\section{Client}

\section{Communication}


\chapter{Proof of concept}

\blockquote{
We can only evaluate the user experience afforded by the toolkit and its features by building applications that use it, and then evaluating them. While the toolkit itself can be evaluated on its technical criteria, the aspects of it that are designed to support a particular user experience can only be evaluated in the context of use and thus must be evaluated indirectly - through applications built with the toolkit. \cite{Infrastructure (2003)} \\}

In previous chapters we evaluated the framework on it's technical criteria by the design and choices made. In this chapter we will answer to our \textit{Goal 2} by implementing the framework.

\section{Motivation}

%Scrum is a popular agile process of developing software. Originally thought as using a whiteboard for scheduling development tasks, it has been hard for to make use of Scrum in distributed teams, or 



Scrum is a popular agile process for developing software. Center of focus is the whiteboard where tasks are coordinated, estimated and assigned. For more on Scrum see \textit{scrum.org}.

We ourselves have used Scrum for several projects but never with the pleasure of a physical Scrumboard. Because we never had a room allocated it simply wasn't possible to maintain a physical Scrumboard in a new space every day. A lot of tools for this problem have sprung up\footnote{Confluence, Scrumwise, Team Foundation, Trello} and made Scrum possible in this scenario, and even for a fully distributed team who would not be gathered physically in the first place.

The reason we can truthfully say this is because we have used the whiteboard for a couple of days in a sprint, and it felt great.

\begin{itemize}
\item Always being able to turn ones head to the huge todo list is great motivation
\item No need for projecting a software tool during Scrum meetings
\end{itemize}

We have established our opinion that the online tools today lack the presence of the whiteboard. If you are able to maintain a physical Scrumboard, another problem surfaces. Maintaining the data is all manual translation form the board to a spreadsheet or the likes.

Many of the downsides of the whiteboard are fixed by these tools; manual translation from board to spreadsheet

\begin{itemize}
\item[] \Large{There is no solution today that digitalizes the whiteboard while maintaining it's presence}
\end{itemize}

\normalsize

\paragraph{First of all} We believe there are several challenges in using Scrum

The context framework as default is distributed by TCP communication.





We have felt on our own body the effects of not having a physical board.


While this project does not cover implementing a Scrumboard which would solve these problems, we have still chosen this as proof of concept because we think it's an interesting topic.

\section{Context awareness}

There are two situations we deem important which we want the Scrumboard to act upon:

\begin{itemize}
\item The standup meeting
\item An individual closeup with the board
\end{itemize}

This leads to three views

\begin{itemize}
\item Standup
\item Closeup
\item Overview. This view is our default for when none of the other contexts are true
\end{itemize}

\section{Design}


\chapter{Conclusion}

\begin{thebibliography}{9}

\bibitem{Dey and Abowd (2000)}
  Dey, A. K., and Abowd, G.D.
  \emph{Towards a better understanding of context and context-awareness. Workshop on the What, Who, Where, When and How Context-awareness, afflicted with the 2000 ACM Conference on Human Factors in Computer Systems},
  2000.
  
\bibitem{Infrastructure (2003)}
  W. Keith Edwards, Victoria Bellotti, Anind K. Dey,
  Mark W. Newman.
  \emph{Stuck in the Middle: The Challenges of
  User-Centered Design and Evaluation for Infrastructure},
  2003.

\end{thebibliography}
\chapter{Appendixes}

\end{document}
